A
/***********************************************************************************************************************************/
B Crazy Binary String
链接：https://ac.nowcoder.com/acm/contest/883/B
来源：牛客网

题意：给你一个01字符串，如果一个区间内的0 的个数和1的个数相等，那么这个子区间就是合法的，问最长的合法子区间长度

题目要求输出两个值，一个是有序的一个是无序的，无序的很好计算，就是0和1的个数字最小的那个乘以2
有序的话设0的权值为-1，求前缀和，前缀和相等的两个区间为合法的，遍历一遍求最长的序列即可

#include<iostream>
#include<cstring>
#include<map>
#include<math.h>
using namespace std;
typedef long long ll;

ll pre[100005];
ll num_0=0,num_1=0; 
//map <int,int> a;
ll a[200010];

int main()
{
	ll n;
	scanf("%lld",&n);
	string s;
	cin>>s;
	ll ans1=0;
	for(ll i=0;i<n;i++)
	{
		if(i==0) pre[0]= s[i]=='0'?-1:1;
		else pre[i]=pre[i-1]+(s[i]=='0'?-1:1);
		if(s[i]=='0') num_0++;
		else num_1++;
	
		if(pre[i]==0) ans1=max(ans1,i+1);//如果pre[i]==0，那么从上一个0位置到i中0的个数和1的个数相等，这是一个合法的序列 
		
		//计算最长子序列，前缀和相等的两个位置中间的0和1的个数相等
		//a数组用来存储相等的前缀和的位置在哪里 
		if(a[pre[i]+100000]){//如果前缀和不为0，就是之前存在这样的前缀和 
		//因为前缀和有可能是负值，所以将前缀和+10w再处理,这样的话下标不会为负数
		//并且前缀和的最大值和最小值也是+-10w 
             ans1=max(ans1,i-(a[100000+pre[i]]==-1?0:a[100000+pre[i]]));
        }
		else//如果之前的前缀和不存在，则在a数组中保存这个位置 
		{
            a[100000+pre[i]]=i;
        }
		
	}
	ll ans2=min(num_1,num_0)*2;
	printf("%lld %lld",ans1,ans2); 
	return 0;
 } 
 
 /***********************************************************************************************************************************/
 C
 /***********************************************************************************************************************************/
 D
 /***********************************************************************************************************************************/
 E
 /***********************************************************************************************************************************/
 F
 /***********************************************************************************************************************************/
 G
 /***********************************************************************************************************************************/
 H Magic Line
 链接：https://ac.nowcoder.com/acm/contest/883/H
来源：牛客网

题意是说在二维平面内有n个点，找出一条线可以平分直线两边的点的个数，
先按照x从小到大排序，接着按照y从小到大排序，选择最中间的两个点，经过这两点之间的线没有办法经过其他的店，所以做到了平分
考虑两种特殊情况
1，这两个点的x坐标是相邻的，这样的话这个连线就在整两个点的上下方找y值，这样的话就是直接穿过了这两个点之间的连线，存在斜率
2.这两个点的x方向的距离大于1，则说明不相邻，这个时候需要在这两点之间求一条垂直于x坐标轴的线，就可以了

#include<iostream>
#include<algorithm>
#define N 100010
using namespace std;
typedef long long ll;
 
struct Node{
    int x,y;
}a[N];
 
int cmp(Node A,Node B)//定义排序函数，x从小到大进行排序，y从大到小进行排序 
{
    if(A.x==B.x)return A.y>B.y;
    return A.x<B.x;
}
 
int main()
{
    ll T; 
    scanf("%lld",&T);
    while(T--){
        ll n;
        scanf("%lld",&n);
        for(int i=0;i<n;i++)
        {
            scanf("%lld%lld",&a[i].x,&a[i].y);
        }
        sort(a,a+n,cmp);
        int x1,x2,y1=999000000,y2=-999000000;//y的定义是在范围之内取得最大数 
        //判断中间的两个点是否相邻 
        if(a[n/2].x>a[n/2-1].x+1)//如果不相邻 
        {
            x1=(a[n/2].x+a[n/2-1].x)/2;//横坐标取两点中点，并且横坐标相等，纵坐标取不同的值，这样的话就是一条垂直于x轴的直线 
            x2=x1;
            y1=1;
            y2=-1;
        }
        else//讨论相邻或者x相等的情况 
        {
        	if(a[n/2].x==a[n/2-1].x)//如果中间两个点的x值相等的话，x1和x2的值就要错开 
			{
	            x1=a[n/2-1].x+1;
	            x2=a[n/2].x-1;				
			 } 
			else//如果不相等花花，他们的距离为1，只需要改变y值就可以了 
			{
	            x1=a[n/2].x;
	            x2=a[n/2-1].x;				
			}

            int y;
            y=(a[n/2-1].y+a[n/2].y);//y定义中间两点的y值之和，就是直线计算斜率的时候一定要偏的程度 
            y1+=y,y2-=y;//让直线的斜率无限接近于1，就是无限接近于一条垂直于x轴的线，
						//这样的话既可以分开两个点，又碰不到其他的点 
						//y1是y正半轴的点，则加上必要值，y2为负半轴的点，可以不减去必要值，而变成原y1的负值 
        }
         
        printf("%d %d %d %d\n",x1,y1,x2,y2);
//      for(int i=0;i<n;i++)
//      printf("%d %d\n",a[i].x,a[i].y);
    }
     
    return 0;
 }
 /***********************************************************************************************************************************/
 I
 /***********************************************************************************************************************************/
 J
