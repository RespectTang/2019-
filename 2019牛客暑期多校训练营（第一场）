A Equivalent Prefixes
链接：https://ac.nowcoder.com/acm/contest/881/A
来源：牛客网
题意是讲在两个序列中找到所有区间的RMQ最小值相同，两种思路，一种是判断两个数组的笛卡尔树形结构是否相同，但至于怎么判断不会
在网络上查了一下有讲通过栈来维护笛卡尔树从而判断结构
笛卡尔树的中序遍历之后是原数组，每一个区间的两个节点距离最近的根节点为这个区间的最小值，可以解决区间RMQ问题

第二种思路是单调栈
遍历整个数组，使得单调栈内部数据单调上升，如果判断到当前数字比栈顶元素要小，则栈顶元素出栈，更新栈内元素的顺序
这样可以保证在循环到的这个区间里的最小值一直是栈底元素
代码为用数组模拟单调栈的写法
#include<iostream>
using namespace std;
int m, a[100100], b[100100];
int c[100100], d[100100];
int main()
{
    while(cin >> m) {
        a[0] = 0;
        b[0] = 0; 
        for (int i = 1; i <= m; i++)
            cin >> a[i];
        for (int i = 1; i <= m; i++)
            cin >> b[i];
        for (int i = 1; i <= m; i++) {
            int p = i - 1;
            while (a[p] > a[i])
                p = c[p];
            c[i] = p;
        }
        for (int i = 1; i <= m; i++) {
            int p = i - 1;
            while (b[p] > b[i])
                p = d[p];
            d[i] = p;
        }
        int sum = 0;
        for (int i = 1; i <= m; i++) {
            if (c[i] == d[i]) sum++;
            else break;
        }
        cout << sum << endl;
    }
}

这个是用单调栈的写法，思路来源于阮节
#include<iostream>
#include<stack>
#include<cstdio>
using namespace std;
int main(){
	int n;
	while(cin>>n){
		stack<int> s1,s2;
		int a[100010],b[100010];
		
		for(int i=0;i<n;i++){
			scanf("%d",&a[i]);
		}
		for(int i=0;i<n;i++){
			scanf("%d",&b[i]);
		}
		
		int k=1;
		s1.push(a[0]);
		s2.push(b[0]);
		while(1){
			if(k==n){
				printf("%d\n",n);
				break;
			} 
			while(1){
				if(!s1.empty()){
					if(a[k]<s1.top()){
						s1.pop();
					}else{
						s1.push(a[k]);
						break;
					}
				}else{
					s1.push(a[k]);
					break;
				}
			}
			while(1){
				if(!s2.empty()){
					if(b[k]<s2.top()){
						s2.pop();
					}else{
						s2.push(b[k]);
						break;
					}
				}else{
					s2.push(b[k]);
					break;
				}
			}
			if(s1.size()==s2.size()){
				k++;
			}else{
				printf("%d\n",k);
				break;
			}
		}
	}
	return 0;
} 


/***********************************************************************************************************************************/
B Integration
/*
链接：https://ac.nowcoder.com/acm/contest/881/B
来源：牛客网
*/

代码和hint来源于zym，zymtql
hint：https://blog.csdn.net/weixin_43702895/article/details/96478844?tdsourcetag=s_pcqq_aiomsg

先对于积分进行裂项相消化简，求出通项公式
然后将积分用换元法算出来，最后的结果为若干个分式的和，对于所有分式取模再求和在取模
对于分数的取模，用到费马小定理求逆元
每一行代码都注释了作用而且教程写得非常详细


#include <iostream>
using namespace std;
typedef long long ll;//推荐用longlong类型，因为有些数据会爆int
const int maxn=1e3+5;//最大n值
const int mod=1e9+7;//模值
int n;
ll a[maxn];
ll qpow(ll x){//快速幂，用来求逆元
	ll sum=1,pow=mod-2;
	while(pow!=0){
		if(pow%2==1)	sum=(ll)sum*x%mod;
		pow>>=1;
		x=(ll)x*x%mod;
	}
	return (sum+mod)%mod;
}
int main(){
	while(~scanf("%d",&n)){
		int i,j;
		ll ans=0,t;
		for(i=1;i<=n;i++)	scanf("%lld",&a[i]);
		for(i=1;i<=n;i++){
			ll res=1;//res来算每一个分数的分母中连乘的结果
			for(j=1;j<=n;j++){
				if(j==i)	continue;//j不等于i
				res=((a[j]*a[j]-a[i]*a[i])%mod+mod)%mod*res%mod;//连乘取模
			}
			ans=(ans+qpow(res*2*a[i]%mod)%mod)%mod;//res*2*a[i]即为每一个分母，ans储存每一个分数取模后的结果
		}
		printf("%lld\n",(ans+mod)%mod);//加起来，再取一次模
	}
	return 0;
} 

/***********************************************************************************************************************************/
C Euclidean Distance
/*
链接：https://ac.nowcoder.com/acm/contest/881/C
来源：牛客网
示例1
输入
1 1
0
2 3
1 2
3 10
1 -2 3
输出
1
0
16/75
*/




#include<iostream>
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
#define N 10010
int n,m;
ll a[N],s2[N];
int main(){
    int i,j;
    while(~scanf("%d%d",&n,&m)){
        ll s=0;
        for(i=1;i<=n;i++)scanf("%lld",&a[i]),s+=a[i];
        sort(a+1,a+1+n);
        for(i=1;i<=n;i++)s2[i]=s2[i-1]+a[i]*a[i];
        for(i=1;i<=n;i++){
            if(a[i]*(n-i+1)-s+m>=0)break;
            s-=a[i];
        }
        ll fz=s2[i-1]*(n-i+1)+(s-m)*(s-m),fm=1LL*m*m*(n-i+1);
        ll g=__gcd(fz,fm);
        fz/=g;fm/=g;
        if(fm==1)printf("%lld\n",fz);
        else printf("%lld/%lld\n",fz,fm);
    }
    return 0;
}
/***********************************************************************************************************************************/
D
/***********************************************************************************************************************************/
E ABBA
链接：https://ac.nowcoder.com/acm/contest/881/E
来源：牛客网

题意：有一个2（n+m）的一个序列只有A和B构成，


/***********************************************************************************************************************************/
F  Random Point in Triangle
/*
链接：https://ac.nowcoder.com/acm/contest/881/F
来源：牛客网
*/
题意很简单，就是告诉你三个点的坐标，在三角形内部任意取一点P，求被P分成的三个子三角形的最大子三角形的面积期望

https://github.com/RespectTang/2019-/blob/master/trangle.png


因为是求求期望，所以无论底边是哪一条都一样，所以讨论以BC为底边
D,E,F分别为三边的中点，所以交点G为重心，所以此时ABG，BCG，ACG这三个小三角形的面积是一样的
BC为底边，如果面积为三个子三角形中的最大面积，所以顶点应该在四边形ADGF中选取，连接DF，则四边形分为在DF上部分和DF下部分

设三角形GDF以DF为底的高为h，因为三角形DFG相似于三角形GBC，所以GBC的高为2h，又因为ABG，BCG，ACG三个三角形面积相等，所以三角形ABC的高为6h
设BC底边长2l
得出最大子面积和总面积的比率Rate=3/4倍顶点在三角形ADF的面积的期望+1/4倍顶点在三角形GDF的面积的期望

分类讨论
(1)在DF上面的部分
平均面积上=1/2*BC*(3h+h')   h'为顶点距离DF的距离
因为在ADF中随意取一点P与DF围成的三角形面积的期望为1/3三角形ADF
即h'=1/3*3h=h
即平均面积上=1/2*2l*4h=4hl
(2)在DF下面的部分
平均面积下=1/2*BC*(3h-h')   h'为顶点距离DF的距离
因为在GDF中随意取一点P与DF围成的三角形面积的期望为1/3三角形GDF
即h'=1/3*h=1/3h
即平均面积上=1/2*2l*(8/3)h=(8/3)hl

三角形ABC的面积为1/2*2l*6h=6hl
代入Rate的式子，得Rate=11/18hl
E=Rate*S

根据三角形面积公式S=1/2[(x1y2-x2y1)+(x2y3-x3y2)+(x3y1-x1y3)] 应该先将点进行逆时针排序
因为可以先选取固定点x1y1，所以将三组坐标按照x进行排序之后，判断最后两个点的y坐标，如果y2>y3则进行交换
E=11/18*1/2[(x1y2-x2y1)+(x2y3-x3y2)+(x3y1-x1y3)]*36
 =11*[(x1y2-x2y1)+(x2y3-x3y2)+(x3y1-x1y3)]

hint:https://www.cnblogs.com/WAautomaton/p/11211864.html

#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long long ll;

struct Node{
	ll x;
	ll y;
};

bool cmp(Node a,Node b)
{
	return a.x<b.x;
	
}


int main()
{
	Node a[3]; 
	while(~scanf("%lld%lld%lld%lld%lld%lld",&a[0].x,&a[0].y,&a[1].x,&a[1].y,&a[2].x,&a[2].y))
	{
		sort(a,a+3,cmp);
		
		if(a[1].y>a[2].y)
		{
			Node temp;
			temp=a[1];
			a[1]=a[2];
			a[2]=temp;
		}
		
		ll s=11*((a[0].x*a[1].y-a[1].x*a[0].y)+(a[1].x*a[2].y-a[2].x*a[1].y)+(a[2].x*a[0].y-a[0].x*a[2].y));
		s=abs(s);
		printf("%lld\n",s);		
	}

}

/*************************************************************************************************************************************/
G
H
I
/************************************************************************************************************************************/
J Fraction Comparision
/*
链接：https://ac.nowcoder.com/acm/contest/881/J
来源：牛客网
题目描述 
Bobo has two fractions x/a and y/b. He wants to compare them. Find the result.
输入描述:
The input consists of several test cases and is terminated by end-of-file.
Each test case contains four integers x, a, y, b.
0≤x,y≤1018 
1≤a,b≤109
* There are at most 
10
5
105 test cases.
输出描述:
For each test case, print `=` if x/a=y/b. Print `<` if x/a<y/b. Print `>` otherwise.
示例1
输入
1 2 1 1
1 1 1 2
1 1 1 1
输出
<
>
=
*/ 

这道题是分数比较大小，思路是将分数先化成带分数，先比较整数部分，之后比较真分数部分，真分数部分通过交叉相乘进行比较
还有就是要特判分子为零的情况，内外最好都要特判一下，因为分子在化成真分数之后很有可能分子取余之后就变成0

#include<iostream>
using namespace std;
typedef long long ll;

int main()
{
	ll x,a,y,b;
	while(~scanf("%lld%lld%lld%lld",&x,&a,&y,&b))
	{
		ll ax=x/a;
		ll by=y/b;
		if(x==0&&y!=0) printf("<\n");
		else if(x!=0&&y==0) printf(">\n");
		else if(x==0&&y==0) printf("=\n");
		else
		{
			if(ax>by) printf(">\n");
			else if(ax<by) printf("<\n");
			else
			{
				x%=a;
				y%=b;
				if(x==0&&y!=0) printf("<\n");
				else if(x!=0&&y==0) printf(">\n");
				else if(x==0&&y==0) printf("=\n");
				else
				{
					if(x*b>a*y) printf(">\n");
					else if(x*b<a*y) printf("<\n");
					else printf("=\n");					
				}
	
			}			
		}
	}
//	cin>>x>>a>>y>>b;
	return 0;
	
}
