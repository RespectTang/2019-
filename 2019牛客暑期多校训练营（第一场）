A
/***********************************************************************************************************************************/
B Integration
/*
链接：https://ac.nowcoder.com/acm/contest/881/B
来源：牛客网
*/

代码和hint来源于zym，zymtql
hint：https://blog.csdn.net/weixin_43702895/article/details/96478844?tdsourcetag=s_pcqq_aiomsg

先对于积分进行裂项相消化简，求出通项公式
然后将积分算出来，最后的结果为一个分式
对于分数的取模，用到费马小定理求逆元
每一行代码都注释了作用而且教程写得非常详细


#include <iostream>
using namespace std;
typedef long long ll;//推荐用longlong类型，因为有些数据会爆int
const int maxn=1e3+5;//最大n值
const int mod=1e9+7;//模值
int n;
ll a[maxn];
ll qpow(ll x){//快速幂，用来求逆元
	ll sum=1,pow=mod-2;
	while(pow!=0){
		if(pow%2==1)	sum=(ll)sum*x%mod;
		pow>>=1;
		x=(ll)x*x%mod;
	}
	return (sum+mod)%mod;
}
int main(){
	while(~scanf("%d",&n)){
		int i,j;
		ll ans=0,t;
		for(i=1;i<=n;i++)	scanf("%lld",&a[i]);
		for(i=1;i<=n;i++){
			ll res=1;//res来算每一个分数的分母中连乘的结果
			for(j=1;j<=n;j++){
				if(j==i)	continue;//j不等于i
				res=((a[j]*a[j]-a[i]*a[i])%mod+mod)%mod*res%mod;//连乘取模
			}
			ans=(ans+qpow(res*2*a[i]%mod)%mod)%mod;//res*2*a[i]即为每一个分母，ans储存每一个分数取模后的结果
		}
		printf("%lld\n",(ans+mod)%mod);//加起来，再取一次模
	}
	return 0;
} 

/***********************************************************************************************************************************/
C Euclidean Distance
/*
链接：https://ac.nowcoder.com/acm/contest/881/C
来源：牛客网
示例1
输入
1 1
0
2 3
1 2
3 10
1 -2 3
输出
1
0
16/75
*/




#include<iostream>
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
#define N 10010
int n,m;
ll a[N],s2[N];
int main(){
    int i,j;
    while(~scanf("%d%d",&n,&m)){
        ll s=0;
        for(i=1;i<=n;i++)scanf("%lld",&a[i]),s+=a[i];
        sort(a+1,a+1+n);
        for(i=1;i<=n;i++)s2[i]=s2[i-1]+a[i]*a[i];
        for(i=1;i<=n;i++){
            if(a[i]*(n-i+1)-s+m>=0)break;
            s-=a[i];
        }
        ll fz=s2[i-1]*(n-i+1)+(s-m)*(s-m),fm=1LL*m*m*(n-i+1);
        ll g=__gcd(fz,fm);
        fz/=g;fm/=g;
        if(fm==1)printf("%lld\n",fz);
        else printf("%lld/%lld\n",fz,fm);
    }
    return 0;
}
/***********************************************************************************************************************************/
D
E
/***********************************************************************************************************************************/
F  Random Point in Triangle
/*
链接：https://ac.nowcoder.com/acm/contest/881/F
来源：牛客网
题目描述 
Bobo has a triangle ABC with A(x1,y1),B(x2,y2) and C(x3,y3). Picking a point P uniformly in triangle ABC, 
he wants to know the expectation value 
E=max{SPAB,SPBC,SPCA} where SXYZ denotes the area of triangle XYZ.Print the value of 
36×E. It can be proved that it is always an integer.
输入描述:
The input consists of several test cases and is terminated by end-of-file.
Each test case contains six integers x1,y1,x2,y2,x3,y3.|x1|,|y1|,|x2|,|y2|,|x3|,|y3|≤108
* There are at most 
10
5
105 test cases.
输出描述:
For each test case, print an integer which denotes the result.
示例1
输入
0 0 1 1 2 2
0 0 0 0 1 1
0 0 0 0 0 0
输出
0
0
0
*/
题意很简单，就是告诉你三个点的坐标，在三角形内部任意取一点P，求被P分成的三个子三角形的最大子三角形的面积期望

https://github.com/RespectTang/2019-/blob/master/trangle.png


因为是求求期望，所以无论底边是哪一条都一样，所以讨论以BC为底边
D,E,F分别为三边的中点，所以交点G为重心，所以此时ABG，BCG，ACG这三个小三角形的面积是一样的
BC为底边，如果面积为三个子三角形中的最大面积，所以顶点应该在四边形ADGF中选取，连接DF，则四边形分为在DF上部分和DF下部分

设三角形GDF以DF为底的高为h，因为三角形DFG相似于三角形GBC，所以GBC的高为2h，又因为ABG，BCG，ACG三个三角形面积相等，所以三角形ABC的高为6h
设BC底边长2l
得出最大子面积和总面积的比率Rate=3/4倍顶点在三角形ADF的面积的期望+1/4倍顶点在三角形GDF的面积的期望

分类讨论
(1)在DF上面的部分
平均面积上=1/2*BC*(3h+h')   h'为顶点距离DF的距离
因为在ADF中随意取一点P与DF围成的三角形面积的期望为1/3三角形ADF
即h'=1/3*3h=h
即平均面积上=1/2*2l*4h=4hl
(2)在DF下面的部分
平均面积下=1/2*BC*(3h-h')   h'为顶点距离DF的距离
因为在GDF中随意取一点P与DF围成的三角形面积的期望为1/3三角形GDF
即h'=1/3*h=1/3h
即平均面积上=1/2*2l*(8/3)h=(8/3)hl

三角形ABC的面积为1/2*2l*6h=6hl
代入Rate的式子，得Rate=11/18hl
E=Rate*S

根据三角形面积公式S=1/2[(x1y2-x2y1)+(x2y3-x3y2)+(x3y1-x1y3)] 应该先将点进行逆时针排序
因为可以先选取固定点x1y1，所以将三组坐标按照x进行排序之后，判断最后两个点的y坐标，如果y2>y3则进行交换
E=11/18*1/2[(x1y2-x2y1)+(x2y3-x3y2)+(x3y1-x1y3)]*36
 =11*[(x1y2-x2y1)+(x2y3-x3y2)+(x3y1-x1y3)]

hint:https://www.cnblogs.com/WAautomaton/p/11211864.html

#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long long ll;

struct Node{
	ll x;
	ll y;
};

bool cmp(Node a,Node b)
{
	return a.x<b.x;
	
}


int main()
{
	Node a[3]; 
	while(~scanf("%lld%lld%lld%lld%lld%lld",&a[0].x,&a[0].y,&a[1].x,&a[1].y,&a[2].x,&a[2].y))
	{
		sort(a,a+3,cmp);
		
		if(a[1].y>a[2].y)
		{
			Node temp;
			temp=a[1];
			a[1]=a[2];
			a[2]=temp;
		}
		
		ll s=11*((a[0].x*a[1].y-a[1].x*a[0].y)+(a[1].x*a[2].y-a[2].x*a[1].y)+(a[2].x*a[0].y-a[0].x*a[2].y));
		s=abs(s);
		printf("%lld\n",s);		
	}

}

/*************************************************************************************************************************************/
G
H
I
/************************************************************************************************************************************/
J Fraction Comparision
/*
链接：https://ac.nowcoder.com/acm/contest/881/J
来源：牛客网
题目描述 
Bobo has two fractions x/a and y/b. He wants to compare them. Find the result.
输入描述:
The input consists of several test cases and is terminated by end-of-file.
Each test case contains four integers x, a, y, b.
0≤x,y≤1018 
1≤a,b≤109
* There are at most 
10
5
105 test cases.
输出描述:
For each test case, print `=` if x/a=y/b. Print `<` if x/a<y/b. Print `>` otherwise.
示例1
输入
1 2 1 1
1 1 1 2
1 1 1 1
输出
<
>
=
*/ 
这道题是分数比较大小，思路是将分数先化成带分数，先比较整数部分，之后比较真分数部分，真分数部分通过交叉相乘进行比较
还有就是要特判分子为零的情况，内外最好都要特判一下，因为分子在化成真分数之后很有可能分子取余之后就变成0

#include<iostream>
using namespace std;
typedef long long ll;

int main()
{
	ll x,a,y,b;
	while(~scanf("%lld%lld%lld%lld",&x,&a,&y,&b))
	{
		ll ax=x/a;
		ll by=y/b;
		if(x==0&&y!=0) printf("<\n");
		else if(x!=0&&y==0) printf(">\n");
		else if(x==0&&y==0) printf("=\n");
		else
		{
			if(ax>by) printf(">\n");
			else if(ax<by) printf("<\n");
			else
			{
				x%=a;
				y%=b;
				if(x==0&&y!=0) printf("<\n");
				else if(x!=0&&y==0) printf(">\n");
				else if(x==0&&y==0) printf("=\n");
				else
				{
					if(x*b>a*y) printf(">\n");
					else if(x*b<a*y) printf("<\n");
					else printf("=\n");					
				}
	
			}			
		}
	}
//	cin>>x>>a>>y>>b;
	return 0;
	
}
