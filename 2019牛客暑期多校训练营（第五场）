A digits

链接：https://ac.nowcoder.com/acm/contest/885/A
来源：牛客网

题意：你有一个数n，让你求另一个数M，满足M可以被n整除，并且M的每一位加起来也可以被n整除

一开始想分类讨论各种情况，结果最终结果和一开始猜测的差不多，直接输出n个n就好了

#include<iostream>
using namespace std;
typedef long long ll;

int main()
{
	ll T;
	scanf("%lld",&T);
	while(T--)
	{
		ll n; 
		scanf("%lld",&n);
				for(int i=1;i<=n/3;i++)
				{
					printf("%lld",n);
				}
				printf("\n");
//		if(n/10==0)
//		{
//			printf("%lld\n",n);
//		}
//		else if(n%3==0)
//		{
//			if((n/3)%2==0)
//				for(int i=1;i<=4;i++)
//				{
//					printf("%lld",n);
//				}
//			else
//				for(int i=1;i<=n/3;i++)
//				{
//					printf("%lld",n);
//				}
//			printf("\n");
//		}
//		else if(n%5==0)
//		{
//			for(int i=1;i<=n/5;i++)
//				{
//					printf("%lld",n);
//				}
//			printf("\n");
//		}
//		else printf("Impossible\n");
	}
	return 0;
 } 
/*****************************************************************************************************************************************/
B generator 1

链接：https://ac.nowcoder.com/acm/contest/885/B
来源：牛客网

题意：广义斐波那契数列求第n项，但是这个n非常的大


题目有两种做法

1.用十进制快速幂对于每一位的n都进行一次乘法计算
hint：https://www.cnblogs.com/zhuyou/p/11285849.html
十进制的快速幂还是会TLE，所以在十进制的基础上应该还要增加二进制二次幂来优化一些常数的幂
大概的思想是将每一位的n拆开，然后res=（res^10）^(n[i]-'0')

#include<bits/stdc++.h>
#define mes(a, b) memset(a, b, sizeof a)
using namespace std;
typedef long long ll;
const int maxn = 1e6+10;
ll mod;
char n[maxn];
 
struct Mat{//定义矩阵 
    ll mat[4][4];
    Mat(){
        mes(mat, 0);
    }
    void init(){
        for(int i = 1; i <= 2; i++)
            mat[i][i] = 1;
    }
 
    Mat operator * (const Mat &a)const{//矩阵乘法 
        Mat ans;
        for(int i = 1; i <= 2; i++){
            for(int j = 1; j <= 2; j++){
                for(int k = 1; k <= 2; k++){
                    ans.mat[i][j] += mat[i][k]*a.mat[k][j]%mod;
                    ans.mat[i][j] %= mod;
                }
            }
        }
        return ans;
    }
};

Mat pow(Mat a, ll b){
    Mat ans;
    ans.init();
    while(b){
        if(b&1)
            ans = ans*a;
        a = a*a;
        b >>= 1;
    }
    return ans;
}
 
int main(){
    ll a, b, x1, x0;
    scanf("%lld%lld%lld%lld", &x0, &x1, &a, &b);
    scanf("%s%lld",n, &mod);
    int len = strlen(n);
    Mat ans; ans.init();
    Mat res;
    res.mat[1][1] = a; res.mat[1][2] = b;
    res.mat[2][1] = 1;
    for(int i = len-1; i >= 0; i--){//
        ans = ans*pow(res, n[i]-'0');//十进制快速幂 计算res=（res^10）^(n[i]-'0')
        res = pow(res, 10ll);//二进制快速幂优化 res^10 
    }
    Mat f;
    f.mat[1][1] = x1;
    f.mat[2][1] = x0;
    f = ans*f;
    printf("%lld\n",f.mat[2][1]);
    return 0;
}


2.在模的意义下广义斐波那契数列存在循环节，寻找循环节来压缩n
hint：https://blog.csdn.net/ftx456789/article/details/98309804

#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 2;
LL mod = 1000000007;
int cnt,ct;
LL pri[100005];
LL num[100005];
struct Matrix
{
    LL m[N][N];
} ;
Matrix A;
Matrix I = {1, 0, 0, 1};
char str[1000005];
map<int,int>y;
Matrix multi(Matrix a,Matrix b)
{
    Matrix c;
    for(int i=0; i<N; i++)
    {
        for(int j=0; j<N; j++)
        {
            c.m[i][j]  =0;
            for(int k=0; k<N; k++)
            {
                c.m[i][j] =(c.m[i][j]+a.m[i][k] * b.m[k][j]%mod)%mod;
            }
        }
    }
    return c;
}
Matrix power(Matrix A,LL n)
{
    Matrix ans = I, p = A;
    while(n>0)
    {
        if(n & 1)
        {
            ans = multi(ans,p);
            n--;
        }
        n >>= 1;
        p = multi(p,p);
    }
    return ans;
}
LL quick_mod(LL a,LL b,LL MOD)
{
    LL ans = 1;
    a %= MOD;
    while(b>0)
    {
        if(b & 1)
        {
            ans = ans * a % MOD;
            b--;
        }
        b >>= 1;
        a = a * a % MOD;
    }
    return ans;
}
LL quick_mul(LL a,LL b,LL MOD)
{
    LL ans=0;
    while(b)
    {
        if(b&1)
            ans=(ans+a)%MOD;
        a=(a+a)%MOD;
        b=b/2;
    }
    return ans;
}
LL Legendre(LL a,LL p,LL MOD)
{
    LL t = quick_mod(a,(p-1)>>1,MOD);
    if(t == 1) return 1;
    return -1;
}
void yinzi(LL x)
{
    for(int i=2; i*i<=x; i++)
    {
        if(x%i==0)
        {
            while(x%i==0)
            {
                y[i]++;
                x=x/i;
            }
        }
    }
    if(x>1)
    {
        y[x]++;
    }
}
LL lcm(LL a,LL b)
{
    return a/__gcd(a,b)*b;
}
LL get_len(LL a,LL b,LL mod)
{
    yinzi(mod);
    for(map<int,int>::iterator i=y.begin(); i!=y.end(); i++)
    {
        pri[cnt]=i->first;
        num[cnt]=i->second;
        cnt++;
    }
    LL ans=1;
    LL c=a*a+4*b;
    for(int i=0; i<cnt; i++)
    {
        LL p=1;
        if(pri[i]==2)
        {
            p*=3;
            for(int j=0; j<=num[i]; j++)
                p*=pri[i];
        }
        else if(c%pri[i]==0)
        {
            p*=pri[i]*(pri[i]-1);
            for(int j=1; j<num[i]; j++)
                p*=pri[i];
        }
        else if(Legendre(c,pri[i],pri[i])==1)
        {
            p*=(pri[i]-1);
            for(int j=1; j<num[i]; j++)
                p*=pri[i];
        }
        else
        {
            p*=(pri[i]-1)*(pri[i]+1);
            for(int j=1; j<num[i]; j++)
                p*=pri[i];
        }
        ans=lcm(ans,p);
    }
    return ans;
}
int main()
{
    LL a,b,c,d;
    cin>>c>>d>>a>>b;
    cin>>str>>mod;
    LL p=get_len(a,b,mod);
    LL n=0;
    int len=strlen(str);
    for(int i=0; i<len; i++)
    {
        n=quick_mul(n,10,p)+str[i]-'0';
    }
    A.m[0][0]=a;
    A.m[0][1]=b;
    A.m[1][0]=1;
    A.m[1][1]=0;
    Matrix T=power(A,n-1);
    long long ans=(T.m[0][0]*d%mod+T.m[0][1]*c%mod)%mod;
    printf("%lld\n",ans);
    return 0;
}




/*****************************************************************************************************************************************/
C
/*****************************************************************************************************************************************/
D
/*****************************************************************************************************************************************/
E
/*****************************************************************************************************************************************/
F
/*****************************************************************************************************************************************/
G
/*****************************************************************************************************************************************/
H
/*****************************************************************************************************************************************/
I
/*****************************************************************************************************************************************/
J
/*****************************************************************************************************************************************/
