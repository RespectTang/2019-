/********************************************************************************************************************************************/
A Garbage Classifacation

链接：https://ac.nowcoder.com/acm/contest/886/A
来源：牛客网

题意：垃圾分类，给了一堆垃圾，判断它是有害垃圾/可回收垃圾/干垃圾/湿垃圾。两行输入，一行字符串表示垃圾，另一行代表每个小写字母的垃圾种类。
模拟就可以了

#include<iostream>
#include<cstdio>
#include<string>
#define sc(x) scanf("%d",&x);
#define ll long long
#define scll(x) scanf("%lld",&x);
using namespace std;
int main(){
    int t;
    sc(t);
    for(int i=1;i<=t;i++){
        string s,t;
        int d=0,w=0,h=0;
        cin >> s >> t;
        for(int i=0;i<s.size();i++){
            if(t[s[i]-'a']=='h') h++;
            if(t[s[i]-'a']=='w') w++;
            if(t[s[i]-'a']=='d') d++;
        }
        int len=s.size();
        if(h*4>=len){
            printf("Case #%d: Harmful\n",i);
            continue;
        }else if(h*10<=len){
            printf("Case #%d: Recyclable\n",i);
            continue;
        }else{
            if(d>=2*w){
                printf("Case #%d: Dry\n",i);
                continue;  
            }else{
                printf("Case #%d: Wet\n",i);
                continue;
            }
        }
    }
    return 0;
}
/********************************************************************************************************************************************/
B Shorten IPv6 Address

链接：https://ac.nowcoder.com/acm/contest/886/B
来源：牛客网

题意：给你一个128位二进制字符串让你转换成十六进制的Ipv6的地址，并合理进行0压缩
/********************************************************************************************************************************************/
C
/********************************************************************************************************************************************/
D Move

链接：https://ac.nowcoder.com/acm/contest/886/D
来源：牛客网

有n个物品，K个盒子，求如果要把这n个物品都塞到这K个盒子中，求最小的盒子容量
一道正常的模拟题，可以遍历盒子的容量，二分的话应该会快一点
但是官方给了反例，不能二分的原因是不满足单调性，所以直接从sum/k到maxvalue枚举遍历就好了
反例如下
n = 15  k = 5
39 39 39 39 39 60 60 60 60 60 100 100 100 100 100
199为合法的答案，但200不是，201也不是。

#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long ll;
const int maxn=10010;
ll n,k;
ll value[maxn],box[maxn];

bool check(int x)
{
	memset(box,0,sizeof(box));
	for(int i=1;i<=k;i++)
	{
		int temp=0;
		for(int j=n;j>=1;j--)
		{
			if(!box[j]&&temp+value[j]<=x)
			{
				box[j]=1;
				temp+=value[j];
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!box[i]) return false; 
	}
	return true;
}



int main()
{
	int T;
	
	cin>>T;
	int cas=0;
	while(T--)
	{
		cas++;
		cin>>n>>k;
		ll sum=0;
		for(int i=1;i<=n;i++)
		{
			cin>>value[i];
			sum+=value[i];
		}
		sort(value+1,value+n+1);
		ll ans=1;
		for(int i=sum/k;i<=sum;i++)//遍历box的容量
		{
			if(check(i))
			{
				ans=i;
				break;
			}
		 } 
		 cout<<"Case #"<<cas<<": "<<ans<<endl;
		
	}
	
	
	return 0;
 } 
/********************************************************************************************************************************************/
E
/********************************************************************************************************************************************/
F
/********************************************************************************************************************************************/
G Is today Friday?

题意：字母A to J代表0到9的数字，但是映射不唯一，给出n组用字母表示的日期，并且这些日期都是星期五，求字母A~J的映射关系

题解：使用next_permutation()函数对于映射进行全排列，这样从前往后扫描就可以使得字典序最小
判断是否为星期五的话可以用蔡勒公式进行判断
蔡勒公式：
1582年10月4日后：w = (d + 1+ 2*m+3*(m+1)/5+y+y/4-y/100+y/400)%7;
1582年10月4日前：w = (d+1+2*m+3*(m+1)/5+y+y/4+5) % 7;

#include<cmath>
#include<cstdio>
#include<string>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<functional>
using namespace std;
#define sc(x) scanf("%d",&x);
#define scll(x) scanf("%lld",&x);
int mon[13]={0,31,28,31,30,31,30,31,31,30,31,30,31},n;
int num[12]={0,1,2,3,4,5,6,7,8,9};
string s[100010];
bool judge(int y,int m,int d){
    if((y%4==0 && y%100!=0) || y%400==0) mon[2]=29;
    else mon[2]=28;
    if(y<1600 || y>9999) return 1;
    if(m<1 || m>12) return 1;
    if(d<1 || d>mon[m]) return 1;
    return 0;
}
bool zaller(int y,int m,int d){
    if(m==1 || m==2) m+=12,y--;
    //基姆拉尔森计算公式
//  return ((d+2*m+3*(m+1)/5+y+y/4-y/100+y/400)%7+1)%7==5?1:0;
    int c=y/100;y=y%100;
    return ((y+y/4+c/4-2*c+26*(m+1)/10+d-1)%7+7)%7==5?1:0;
}
bool check(){
    for(int i=0;i<n;i++){
        int y=0,m=0,d=0;
        y=num[(s[i][0]-'A')]*1000+num[(s[i][1]-'A')]*100+num[(s[i][2]-'A')]*10+num[(s[i][3]-'A')];
        m=num[(s[i][5]-'A')]*10+num[(s[i][6]-'A')];
        d=num[(s[i][8]-'A')]*10+num[(s[i][9]-'A')];
//      printf("%d:%d:%d\n",y,m,d);
        if(judge(y,m,d)) return 0;
        if(zaller(y,m,d)==0) return 0;
    }
    return 1;
}
int main(){
    int x,t;sc(t);x=t;
    while(t--){
        sc(n);
        for(int i=0;i<n;i++) cin >> s[i];
        sort(s,s+n);
        n=unique(s,s+n)-s;
//      for(int i=0;i<n;i++) cout << endl << s[i] << endl;
        for(int i=0;i<10;i++) num[i]=i;
        bool flag=0;
        printf("Case #%d: ",x-t);
        do{
            if(check()){
                flag=1;
                for(int j=0;j<10;j++)
                    printf("%d",num[j]);
                printf("\n");
                break;
            }
        }while(next_permutation(num,num+10));
        if(!flag)
            printf("Impossible\n");
    }
    return 0;
}
/********************************************************************************************************************************************/
H
/********************************************************************************************************************************************/
I
/********************************************************************************************************************************************/
J
/********************************************************************************************************************************************/
