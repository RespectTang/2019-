/********************************************************************************************************************************************/
A Garbage Classifacation

链接：https://ac.nowcoder.com/acm/contest/886/A
来源：牛客网

题意：垃圾分类，给了一堆垃圾，判断它是有害垃圾/可回收垃圾/干垃圾/湿垃圾。两行输入，一行字符串表示垃圾，另一行代表每个小写字母的垃圾种类。
模拟就可以了

#include<iostream>
#include<cstdio>
#include<string>
#define sc(x) scanf("%d",&x);
#define ll long long
#define scll(x) scanf("%lld",&x);
using namespace std;
int main(){
    int t;
    sc(t);
    for(int i=1;i<=t;i++){
        string s,t;
        int d=0,w=0,h=0;
        cin >> s >> t;
        for(int i=0;i<s.size();i++){
            if(t[s[i]-'a']=='h') h++;
            if(t[s[i]-'a']=='w') w++;
            if(t[s[i]-'a']=='d') d++;
        }
        int len=s.size();
        if(h*4>=len){
            printf("Case #%d: Harmful\n",i);
            continue;
        }else if(h*10<=len){
            printf("Case #%d: Recyclable\n",i);
            continue;
        }else{
            if(d>=2*w){
                printf("Case #%d: Dry\n",i);
                continue;  
            }else{
                printf("Case #%d: Wet\n",i);
                continue;
            }
        }
    }
    return 0;
}
/********************************************************************************************************************************************/
B
/********************************************************************************************************************************************/
C
/********************************************************************************************************************************************/
D Move

链接：https://ac.nowcoder.com/acm/contest/886/D
来源：牛客网

有n个物品，K个盒子，求如果要把这n个物品都塞到这K个盒子中，求最小的盒子容量
一道正常的模拟题，可以遍历盒子的容量，二分的话应该会快一点
但是官方给了反例，不能二分的原因是不满足单调性，所以直接从sum/k到maxvalue枚举遍历就好了
反例如下
n = 15  k = 5
39 39 39 39 39 60 60 60 60 60 100 100 100 100 100
199为合法的答案，但200不是，201也不是。

#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long ll;
const int maxn=10010;
ll n,k;
ll value[maxn],box[maxn];

bool check(int x)
{
	memset(box,0,sizeof(box));
	for(int i=1;i<=k;i++)
	{
		int temp=0;
		for(int j=n;j>=1;j--)
		{
			if(!box[j]&&temp+value[j]<=x)
			{
				box[j]=1;
				temp+=value[j];
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!box[i]) return false; 
	}
	return true;
}



int main()
{
	int T;
	
	cin>>T;
	int cas=0;
	while(T--)
	{
		cas++;
		cin>>n>>k;
		ll sum=0;
		for(int i=1;i<=n;i++)
		{
			cin>>value[i];
			sum+=value[i];
		}
		sort(value+1,value+n+1);
		ll ans=1;
		for(int i=sum/k;i<=sum;i++)//遍历box的容量
		{
			if(check(i))
			{
				ans=i;
				break;
			}
		 } 
		 cout<<"Case #"<<cas<<": "<<ans<<endl;
		
	}
	
	
	return 0;
 } 
/********************************************************************************************************************************************/
E
/********************************************************************************************************************************************/
F
/********************************************************************************************************************************************/
G
/********************************************************************************************************************************************/
H
/********************************************************************************************************************************************/
I
/********************************************************************************************************************************************/
J
/********************************************************************************************************************************************/
