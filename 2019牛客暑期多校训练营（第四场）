这次居然有11道题

A
B
C
D
E
F
G
H
I
J
/**************************************************************************************************************************************/
K number
链接：https://ac.nowcoder.com/acm/contest/884/K
来源：牛客网

题意：给你一个由数字组成的字符串，求这个字符串中能被300整除的数字个数

这道题的题解方法有两种，
第一种是大家都会想到的一个普通解法，即首先找到两个连续的2个以上的0
然后对这个数组求前缀和并对前缀和中的每一个数字对3取模
然后找到相等的前缀和，相等的前缀和这个区间可以被3整除
即遇到0的时候向前找有多少个前缀和相等的区间，然后答案为0的个数*前面区间的个数
题解很简单but中间会有各种各样的奇怪的bug出现

代码来源于张怡，我觉得写的有一点点复杂

#include <cstdio>
#include <algorithm>
#include <iostream>
#include <map>
#include <string>
#include <cstring>
#include <queue>
#include <stack>
#include <cmath>
#define int long long
#define Mod 1000000007
#define pi (acos(-1))
#define inf 0x3f3f3f3f
#define M 100005
using namespace std;
 
int aa[M];
int a[M];
int m[M];
int ans2[M];
int ans1[M];
int ans0[M];
 
signed main(){
    char s[M];
    gets(s);
    int n=strlen(s);
    int sum=0;
    a[0]=0;
    a[0]=0;
    int k=0;
    for(int i = 0 ; s[i] != '\0' ; i ++ )
    {
        a[i+1]=a[i]+s[i]-'0';
        aa[i+1]=s[i]-'0';
        m[i+1]=a[i+1]%3;
        if(s[i]=='0')
        {
            k++;
            sum+=k;
        }
        else
        {
            k=0;
        }
    }
    aa[n+1]=1;
    aa[n+2]=1;
    for(int i = 1 ; i <= n ; i ++ )
    {
        if(m[i]==0)
        {
            ans0[i]=ans0[i-1]+1;
            ans1[i]=ans1[i-1];
            ans2[i]=ans2[i-1];
        }
        else if(m[i]==1)
        {
            ans0[i]=ans0[i-1];
            ans1[i]=ans1[i-1]+1;
            ans2[i]=ans2[i-1];
        }
        else if(m[i]==2)
        {
            ans0[i]=ans0[i-1];
            ans1[i]=ans1[i-1];
            ans2[i]=ans2[i-1]+1;
        }
    }
     
//  for(int i = 1 ; i <= n ; i ++ )
//  printf("%lld %lld %lld\n",ans0[i],ans1[i],ans2[i]);
// 
//  printf("%lld\n",sum);
    int last=0;
    int cnt=0;
    int lp=0;
    for(int i = 1 ; i <= n+2 ; i ++ )
    {
         
        if(aa[i]!=0&&aa[i-1]==0&&aa[i-2]==0&&(i-2)>0&&lp>0)
        {
//      cout<<lp<<endl;
//          printf("111\n");
            if(last==1)
            sum+=(ans1[lp-1])*(cnt-1);
            else if(last==2)
            sum+=ans2[lp-1]*(cnt-1);
            else sum+=(ans0[lp-1]+1)*(cnt-1);
        }
        if(aa[i]==0&&aa[i-1]==0&&aa[i-2]!=0&&(i-2)>0)
        {
            last=m[i-2];
            lp=i-2;
//          cout<< lp <<endl;
        }
        if(aa[i]==0)
        cnt++;
        else
        cnt=0;
//      printf("%lld %lld %lld\n",ans0[i],ans1[i],ans2[i]);
//      cout<<sum<<endl;
    }
    printf("%lld",sum);
    return 0;
}



第二种思路来自于阮节；
设一个数组只有三个数字，b[0]b[1]b[2]，来统计联系单两个0之后前缀和中的0,1,2的个数
注意的是一个转移的思想
扫到0，则之前的1,和2不变，b[0]++
扫到1,之前的b[2]-=1,b[0]++,因为1+2=3%3=0，这样的话就是b[2]的数字被1抵消
扫到2，同理可得b[1]-=1,b[0]++
每次扫到的00合法位置之前的合法序列为b[0]的个数

代码：
#include <iostream>
#include <cstdio>
#define ll long long
 
using namespace std;
 
string a;
ll b[4];
int main(){
    cin >> a;
    ll co = 0;
    int flag = 0;
    for(int i = 0; i < a.size(); i++){
        if(a[i] - '0' == 0){
            flag++;
            co++;
        }
        else flag = 0;
        if(flag >= 2) co = co + b[0];
         
        if((a[i] - '0') % 3 == 1){
            ll t = b[2];
            b[2] = b[1];
            b[1] = b[0] + 1;
            b[0] = t;
        }
        else if((a[i] - '0') % 3 == 2){
            ll t = b[1];
            b[1] = b[2];
            b[2] = b[0] + 1;
            b[0] = t;
        }
        else b[0]++;
    }
    cout << co << endl;
    return 0;
}

婷艳的代码，是件不容易超但是内存占用很爆炸的样子，用一个dp数组直接对于300思考能不能整除
#include<iostream>
#include<string>
using namespace std;
typedef long long ll;
int dp[100010][300];
int main(){
    string s;
    cin >> s;
    int now=0;
    ll ans=0;
    for(int i=0;i<s.size();i++){
        dp[i][s[i]-'0']++;
        for(int j=0;j<300;j++){
            dp[i+1][(j*10+s[i+1]-'0')%300]+=dp[i][j];
        }  
        ans+=dp[i][0];
    }
    printf("%lld",ans);
    return 0;
}
这一个算是上一个的进化版？为什么一个签到题要有这么多的思路和代码emm
#include<iostream>
using namespace std;
typedef long long ll;
int main(){
    string s;
    int dp[3]={1,0,0};//dp存储对于每一个合法位置之前的合法区间的个数
    int now=0;
    ll ans=0;
    cin >> s;
    for(int i=0;i<s.size();i++){//用一次遍历就可以做到 
        now=(now*10+s[i]-'0')%3;//now当前位存储的位置取模后的数字 
        if(i<s.size()-1&&s[i]=='0'&&s[i+1]=='0')//如果找到了两个连续的0，即合法位置 
            ans+=dp[now];//对于每一个合法的位置，将之前的合法区间的个数相加，合法位置的now一定是0 
        if(s[i]=='0')//每一个0也是一种合法答案 
            ans++;
        dp[now]++;//记录每一个120出现的次数 
    }
    printf("%lld",ans);
    return 0;
}
