这是一次全队爆零的惊险体验
太刺激了
/*****************************************************************************************************************************************/
A
/*****************************************************************************************************************************************/
B
/*****************************************************************************************************************************************/
C
/*****************************************************************************************************************************************/
D
/*****************************************************************************************************************************************/
E
/*****************************************************************************************************************************************/
F Partition problem
链接：https://ac.nowcoder.com/acm/contest/882/F
来源：牛客网

题意：有2N个人，将他们分配到每一个队伍都有N个人的两支队伍中，已知每一个人对于其他人的竞争力，要求你将这些人分配后得到最大竞争力
比如说有四个人，1 2 3 4 ，分配1 2 一个队伍，3 4 一个队伍，则竞争力的计算为13+14+23+24
设分为AB两队，因为总人数和每队人数是确定的，因此只需要知道A的序列之后就相当于唯一确定了B的序列
因为我们只考虑枚举A集合的状态，且最开始A集合的状态为1，那么，之后的过程必定是要选取B集合中的某一个数加到A集合中，
假设我们现在要将原本在B集合中的ai加到A集合中。
那么显然，我们只需要将ai原来跟A集合中的所有点点贡献删除，并增加现在在B集合中的点跟ai的贡献。故此时，我们直接可以用O(n)的时间复杂度进行更新答案。

#include <bits/stdc++.h>
#define maxn 40
using namespace std;
typedef unsigned long long ll;
ll res=0;
int n,v[maxn][maxn];
//sta是状压了一个2*n位的二进制位，代表当前A集合选取的状态，若当前位为1则代表选1
//cnt代表A选取了的状态
//pre代表当前已经选了前pre个点
//cost代表贡献
void dfs(int sta,int cnt,int pre,ll cost){
    if(cnt==n/2){ //两边集合相同，更新答案
        res=max(res,cost);
        return;
    }
    if(n-pre-1+cnt<n/2) return; //剪枝，如果发现A集合的数量大于B集合的数量，直接终止
    for(int i=pre+1;i<n;i++){ //枚举当前需要将第i个点加到A集合中
        ll cur=cost;
        for(int j=0;j<n;j++){
            if(sta&(1<<j)) cur-=v[i][j]; //如果在原来的状态下第j位是处在A集合中，则直接减去第i个点在第j个点的贡献
            else cur+=v[i][j]; //如果在原来的状态下第j位是处在B集合中，则直接加上第i个点在第j个点的贡献
        }
        dfs(sta|(1<<i),cnt+1,i,cur);
    }
}
int main()
{
    scanf("%d",&n);
    n<<=1;//将2N的规模压缩为N 
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            scanf("%d",&v[i][j]);
    for(int i=0;i<n;i++){
        res+=v[0][i];
    }
    dfs(1,1,0,res);
    printf("%llu\n",res);
    return 0;
}

/*****************************************************************************************************************************************/
G
/*****************************************************************************************************************************************/
H
/*****************************************************************************************************************************************/
I
/*****************************************************************************************************************************************/
J
