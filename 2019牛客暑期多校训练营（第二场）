这是一次全队爆零的惊险体验
太刺激了
/*****************************************************************************************************************************************/
A
/*****************************************************************************************************************************************/
B
/*****************************************************************************************************************************************/
C
/*****************************************************************************************************************************************/
D
/*****************************************************************************************************************************************/
E
/*****************************************************************************************************************************************/
F Partition problem
链接：https://ac.nowcoder.com/acm/contest/882/F
来源：牛客网

hint：https://www.cnblogs.com/Chen-Jr/p/11221929.html

题意：有2N个人，将他们分配到每一个队伍都有N个人的两支队伍中，已知每一个人对于其他人的竞争力，要求你将这些人分配后得到最大竞争力
比如说有四个人，1 2 3 4 ，分配1 2 一个队伍，3 4 一个队伍，则竞争力的计算为13+14+23+24
设分为AB两队，因为总人数和每队人数是确定的，因此只需要知道A的序列之后就相当于唯一确定了B的序列
因为我们只考虑枚举A集合的状态，且最开始A集合的状态为1，那么，之后的过程必定是要选取B集合中的某一个数加到A集合中，
假设我们现在要将原本在B集合中的ai加到A集合中。
那么显然，我们只需要将ai原来跟A集合中的所有点点贡献删除，并增加现在在B集合中的点跟ai的贡献。故此时，我们直接可以用O(n)的时间复杂度进行更新答案。

#include <bits/stdc++.h>
#define maxn 40
using namespace std;
typedef unsigned long long ll;
ll res=0;
int n,v[maxn][maxn];
//sta是状压了一个2*n位的二进制位，代表当前A集合选取的状态，若当前位为1则代表选1
//cnt代表A选取了的状态
//pre代表当前已经选了前pre个点
//cost代表贡献
void dfs(int sta,int cnt,int pre,ll cost){
    if(cnt==n/2){ //两边集合相同，更新答案
        res=max(res,cost);
        return;
    }
    if(n-pre-1+cnt<n/2) return; //剪枝，如果发现A集合的数量大于B集合的数量，直接终止
    for(int i=pre+1;i<n;i++){ //枚举当前需要将第i个点加到A集合中
        ll cur=cost;
        for(int j=0;j<n;j++){
            if(sta&(1<<j)) cur-=v[i][j]; //如果在原来的状态下第j位是处在A集合中，则直接减去第i个点在第j个点的贡献
            else cur+=v[i][j]; //如果在原来的状态下第j位是处在B集合中，则直接加上第i个点在第j个点的贡献
        }
        dfs(sta|(1<<i),cnt+1,i,cur);
    }
}
int main()
{
    scanf("%d",&n);
    n<<=1;//将2N的规模压缩为N 
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            scanf("%d",&v[i][j]);
    for(int i=0;i<n;i++){
        res+=v[0][i];
    }
    dfs(1,1,0,res);
    printf("%llu\n",res);
    return 0;
}

/*****************************************************************************************************************************************/
G
/*****************************************************************************************************************************************/
H Second Large Rectangle
链接：https://ac.nowcoder.com/acm/contest/882/H
来源：牛客网

题意是说给你一个矩阵，让你找到第二大全1矩阵的大小

POJ2559是这道题的一维版本，肖焰今天下午写了这道题但是一直找不出来bug，最后发现是因为while循环之后站和叔祖没有清空导致的
POJ链接：http://poj.org/problem?id=2559
#include <cstdio>
#include <algorithm>
#include <stack>
using namespace std;

typedef long long ll;
ll h[100005] = {0};

stack<int> s;

int main()
{
	int n;
	while (scanf("%d", &n)!= EOF) {
		if (n==0) break;
		for (int i = 0; i < n; i++) 
			scanf("%lld", &h[i]);
		
		ll j = 0, res = 0;
		while (j<=n) {
			if (s.empty()||h[s.top()]<=h[j])
				s.push(j++);
			else {
				ll t = s.top(); s.pop();
				ll wid = s.empty()?j:(j-s.top()-1);
				res = max(res, h[t]*wid);
			}
		}
		printf("%lld\n", res);
		//注：用完之后要清空h数组，否则会出现被覆盖的现象 
	}
	
} 

这道题的思路为每一行的矩阵都化成一个高度直方图，然后寻找最大矩阵，每一行记录一个这一行可以到达的最大矩阵面积
用两个单调栈来维护当前矩阵可以向左和向右扩展可以扩展到的和最右边，然后面积为(r-l)*h
然后需要做的一个工作就是去重，因为第二大面积不想第一大面积一样是一个唯一的确定的值，
第二大面积可能是第一大面积的子面积，也可能来自于另外一个新的矩形，例如101的输出结果是1而不是0，
所以判断如果有两个矩形左右两边相等并且面积相等的话，我们定义他们是同一个矩形，所以去掉相同的矩形，
例如111，这样的话就可以只存储一次次大矩形为2而不是存储三次
如果第二大矩形是第一大矩形的子面积，那么计算的方法为长-1或者宽-1，这样进行计算

hint：https://www.cnblogs.com/FrankChen831X/p/11221455.html
别问，问就是不会单调栈只会写数组
#include<cstdio>
#include<algorithm>
using namespace std;

int n,m,p1,p2,max1,max2;
int a[1005][1005],stk1[1005],stk2[1005];
int l[1005],r[1005];
char s[1005];
int mx,my,xx,yy;

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i){
        a[i][0]=-1,a[i][m+1]=-1;
        scanf("%s",s);
        for(int j=1;j<=m;++j){//初始化为高度矩阵 
            int tmp=s[j-1]-'0';
            if(tmp) a[i][j]=a[i-1][j]+1;
        }
    }
    stk1[0]=0,stk2[0]=m+1;//用数组模拟单调栈 
    for(int i=1;i<=n;++i){
        p1=p2=1;
        for(int j=1;j<=m;++j){//寻找最右边
            while(a[i][stk1[p1-1]]>=a[i][j]) --p1;
            l[j]=stk1[p1-1];
            stk1[p1++]=j;
        }
        for(int j=m;j>=1;--j){//从后往前寻找最左边 
            while(a[i][stk2[p2-1]]>=a[i][j]) --p2;
            r[j]=stk2[p2-1];
            stk2[p2++]=j;
        }
        for(int j=1;j<=m;++j){
            int x=r[j]-l[j]-1,y=a[i][j];
            if(!y) continue; 
            int aa=i,bb=r[j]-1;
            if(x*y>=max1){//去重 
            /*
			max1维护最大矩阵的大小，max2维护次大矩阵的大小，
			mx、my维护最大矩阵的右下角下标，xx、yy维护最大矩阵的长和宽，
			若当前面积值>=max1,需要比较是否是同一个矩阵（by mx、my、xx、yy是否相等来比较），
			若是，则不能更新max2=max1,否则，即不是一个矩阵，则可以max2=max1.
			*/ 
                if(!(aa==mx&&bb==my&&x==xx&&y==yy)) 
                    max2=max1;
                max1=x*y,mx=aa,my=bb,xx=x,yy=y;
            }
            else if(x*y>max2)
                max2=x*y;
            max2=max(max2,max((x-1)*y,x*(y-1)));
        }
    }
    printf("%d\n",max2);
    return 0;
}

/*****************************************************************************************************************************************/
I
/*****************************************************************************************************************************************/
J
